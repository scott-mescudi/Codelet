
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>codelet: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/scott-mescudi/codelet/main.go (0.0%)</option>
				
				<option value="file1">github.com/scott-mescudi/codelet/service/api/snippets/code.go (76.8%)</option>
				
				<option value="file2">github.com/scott-mescudi/codelet/service/api/users/helpers.go (100.0%)</option>
				
				<option value="file3">github.com/scott-mescudi/codelet/service/api/users/user.go (62.4%)</option>
				
				<option value="file4">github.com/scott-mescudi/codelet/service/data_access/snippets.go (56.9%)</option>
				
				<option value="file5">github.com/scott-mescudi/codelet/service/data_access/user.go (78.9%)</option>
				
				<option value="file6">github.com/scott-mescudi/codelet/service/middleware/auth.go (100.0%)</option>
				
				<option value="file7">github.com/scott-mescudi/codelet/service/middleware/cors.go (0.0%)</option>
				
				<option value="file8">github.com/scott-mescudi/codelet/service/server.go (0.0%)</option>
				
				<option value="file9">github.com/scott-mescudi/codelet/shared/auth/hmac_jwt.go (80.0%)</option>
				
				<option value="file10">github.com/scott-mescudi/codelet/shared/auth/validate_hmac_jwt.go (75.0%)</option>
				
				<option value="file11">github.com/scott-mescudi/codelet/shared/compression/zstd.go (83.3%)</option>
				
				<option value="file12">github.com/scott-mescudi/codelet/shared/errors/errResponse.go (66.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        srv "github.com/scott-mescudi/codelet/service"
)

func main() <span class="cov0" title="0">{
        srv.NewCodeletServer()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package snippets

import (
        "net/http"
        "strconv"
        "strings"
        "sync"
        "time"

        jsoniter "github.com/json-iterator/go"
        dba "github.com/scott-mescudi/codelet/service/data_access"
        errs "github.com/scott-mescudi/codelet/shared/errors"
)

var SnippetPool = &amp;sync.Pool{
        New: func() any <span class="cov8" title="1">{
                return &amp;Snippet{}
        }</span>,
}

var json = jsoniter.ConfigCompatibleWithStandardLibrary

func (s *SnippetService) AddSnippet(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Header.Get("Content-Type") != "application/json" </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "AddSnippet").Str("origin", r.RemoteAddr).Msg("Invalid Content-Type, expected application/json")
                errs.ErrorWithJson(w, http.StatusBadRequest, "Content-Type must be 'application/json'")
                return
        }</span>
        <span class="cov8" title="1">defer r.Body.Close()

        useridStr := r.Header.Get("X-USERID")
        if useridStr == "" </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "AddSnippet").Str("origin", r.RemoteAddr).Msg("Missing 'X-USERID' header")
                errs.ErrorWithJson(w, http.StatusBadRequest, "missing 'X-USERID' header")
                return
        }</span>

        <span class="cov8" title="1">userID, err := strconv.Atoi(useridStr)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Warn().Str("function", "AddSnippet").Str("origin", r.RemoteAddr).Msg("invalid 'X-USERID' header format")
                errs.ErrorWithJson(w, http.StatusInternalServerError, "invalid 'X-USERID' header format")
                return
        }</span>

        <span class="cov8" title="1">var info = SnippetPool.Get().(*Snippet)
        defer SnippetPool.Put(info)
        if err := json.NewDecoder(r.Body).Decode(&amp;info); err != nil </span><span class="cov8" title="1">{
                s.Logger.Warn().Int("userID", userID).Str("function", "AddSnippet").Str("origin", r.RemoteAddr).Msg("unable to parse request body")
                errs.ErrorWithJson(w, http.StatusUnprocessableEntity, "unable to parse request body")
                return
        }</span>

        <span class="cov8" title="1">if info.Title == "" </span><span class="cov8" title="1">{
                s.Logger.Warn().Int("userID", userID).Str("function", "AddSnippet").Str("origin", r.RemoteAddr).Msg("Missing snippet title")
                errs.ErrorWithJson(w, http.StatusBadRequest, "missing title")
                return
        }</span>

        <span class="cov8" title="1">if info.Language == "" </span><span class="cov8" title="1">{
                s.Logger.Warn().Int("userID", userID).Str("function", "AddSnippet").Str("origin", r.RemoteAddr).Msg("Missing snippet language")
                errs.ErrorWithJson(w, http.StatusBadRequest, "missing language")
                return
        }</span>

        <span class="cov8" title="1">if info.Code == "" </span><span class="cov8" title="1">{
                s.Logger.Warn().Int("userID", userID).Str("function", "AddSnippet").Str("origin", r.RemoteAddr).Msg("Missing snippet code")
                errs.ErrorWithJson(w, http.StatusBadRequest, "missing code text")
                return
        }</span>

        <span class="cov8" title="1">if len(info.Code) &gt; 3072 </span><span class="cov8" title="1">{
                s.Logger.Warn().Int("userID", userID).Str("function", "AddSnippet").Str("origin", r.RemoteAddr).Msg("Data too large")
                errs.ErrorWithJson(w, http.StatusRequestEntityTooLarge, "code too large")
                return
        }</span>

        <span class="cov8" title="1">if err := dba.AddSnippet(s.Db, userID, info.Language, info.Description, info.Title, info.Code, info.Private, info.Favorite, info.Tags, time.Now(), time.Now()); err != nil </span><span class="cov0" title="0">{
                s.Logger.Error().Int("userID", userID).Str("function", "AddSnippet").Str("origin", r.RemoteAddr).Msg(err.Error())
                errs.ErrorWithJson(w, http.StatusInternalServerError, "failed to add snippet to database")
                return
        }</span>

        <span class="cov8" title="1">s.Logger.Info().Int("userID", userID).Str("function", "AddSnippet").Str("origin", r.RemoteAddr).Msg("Served user")
        w.WriteHeader(http.StatusCreated)</span>
}

func (s *SnippetService) GetUserSnippets(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        defer r.Body.Close()
        useridStr := r.Header.Get("X-USERID")
        if useridStr == "" </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "GetUserSnippets").Str("origin", r.RemoteAddr).Msg("Missing 'X-USERID' header")
                errs.ErrorWithJson(w, http.StatusBadRequest, "missing 'X-USERID' header")
                return
        }</span>

        <span class="cov8" title="1">userID, err := strconv.Atoi(useridStr)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Warn().Str("function", "GetUserSnippets").Str("origin", r.RemoteAddr).Msg("invalid 'X-USERID' header format")
                errs.ErrorWithJson(w, http.StatusInternalServerError, "invalid 'X-USERID' header format")
                return
        }</span>

        <span class="cov8" title="1">params := r.URL.Query()
        limitstr := params.Get("limit")
        pagestr := params.Get("page")

        var snippets []dba.DBsnippet
        if limitstr == "" || pagestr == "" </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "GetUserSnippets").Str("origin", r.RemoteAddr).Msg("missing 'limit' or 'page' parametr")
                errs.ErrorWithJson(w, http.StatusBadRequest, "Missing 'limit' or 'page' parameter")
                return
        }</span>

        <span class="cov8" title="1">limit, err := strconv.Atoi(limitstr)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Warn().Str("function", "GetUserSnippets").Str("origin", r.RemoteAddr).Msg("invalid 'limit' parameter")
                errs.ErrorWithJson(w, http.StatusBadRequest, "invalid 'limit' parameter")
                return
        }</span>

        <span class="cov8" title="1">page, err := strconv.Atoi(pagestr)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Warn().Str("function", "GetUserSnippets").Str("origin", r.RemoteAddr).Msg("invalid 'page' parameter")
                errs.ErrorWithJson(w, http.StatusBadRequest, "invalid 'page' parameter")
                return
        }</span>

        <span class="cov8" title="1">if limit &lt;= 0 || page &lt;= 0 </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "GetUserSnippets").Str("origin", r.RemoteAddr).Msg("limit or page is smaller or equal to 0")
                errs.ErrorWithJson(w, http.StatusBadRequest, "'limit' and 'page' parameter must be greater than 0")
                return
        }</span>

        <span class="cov8" title="1">if limit &gt; 100 </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "GetUserSnippets").Str("origin", r.RemoteAddr).Msg("max 'limit' is 100")
                errs.ErrorWithJson(w, http.StatusBadRequest, "max 'limit' is 100")
                return
        }</span>

        <span class="cov8" title="1">offset := (page - 1) * limit
        snippets, err = dba.GetSnippetsByUserID(s.Db, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error().Int("userID", userID).Str("function", "GetUserSnippets").Str("origin", r.RemoteAddr).Msg("failed to fetch snippets")
                errs.ErrorWithJson(w, http.StatusInternalServerError, "failed to fetch snippets from database")
                return
        }</span>

        <span class="cov8" title="1">if len(snippets) == 0 </span><span class="cov8" title="1">{
                s.Logger.Warn().Int("userID", userID).Str("function", "GetUserSnippets").Str("origin", r.RemoteAddr).Msg("no snippets found for user")
                errs.ErrorWithJson(w, http.StatusNotFound, "no snippets found for user")
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(snippets); err != nil </span><span class="cov0" title="0">{
                s.Logger.Error().Int("userID", userID).Str("function", "GetUserSnippets").Str("origin", r.RemoteAddr).Msg("failed to encode snippets")
                errs.ErrorWithJson(w, http.StatusInternalServerError, "failed to encode snippets as JSON")
                return
        }</span>
}

func (s *SnippetService) GetPublicSnippets(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        defer r.Body.Close()
        params := r.URL.Query()
        limitstr := params.Get("limit")
        pagestr := params.Get("page")

        if limitstr == "" || pagestr == "" </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "GetPublicSnippets").Str("origin", r.RemoteAddr).Msg("missing 'limit' or 'page' url parameter")
                errs.ErrorWithJson(w, http.StatusBadRequest, "missing 'limit' or 'page' url parameter.")
                return
        }</span>

        <span class="cov8" title="1">var snippets []dba.DBsnippet

        limit, err := strconv.Atoi(limitstr)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Warn().Str("function", "GetPublicSnippets").Str("origin", r.RemoteAddr).Msg("invalid 'limit' parameter")
                errs.ErrorWithJson(w, http.StatusBadRequest, "invalid 'limit' parameter")
                return
        }</span>

        <span class="cov8" title="1">page, err := strconv.Atoi(pagestr)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Warn().Str("function", "GetPublicSnippets").Str("origin", r.RemoteAddr).Msg("invalid 'page' parameter")
                errs.ErrorWithJson(w, http.StatusBadRequest, "invalid 'page' parameter")
                return
        }</span>

        <span class="cov8" title="1">if limit &lt;= 0 || page &lt;= 0 </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "GetUserSnippets").Str("origin", r.RemoteAddr).Msg("limit or page is smaller or equal to 0")
                errs.ErrorWithJson(w, http.StatusBadRequest, "'limit' and 'page' parameter must be greater than 0")
                return
        }</span>

        <span class="cov8" title="1">if limit &gt; 100 </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "GetPublicSnippets").Str("origin", r.RemoteAddr).Msg("max 'limit' is 100")
                errs.ErrorWithJson(w, http.StatusBadRequest, "max 'limit' is 100")
                return
        }</span>

        <span class="cov8" title="1">offset := (page - 1) * limit
        snippets, err = dba.GetPublicSnippets(s.Db, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error().Str("function", "GetPublicSnippets").Str("origin", r.RemoteAddr).Msg("failed to fetch public snippets")
                errs.ErrorWithJson(w, http.StatusInternalServerError, "failed to fetch snippets from database")
                return
        }</span>

        <span class="cov8" title="1">if len(snippets) == 0 </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "GetPublicSnippets").Str("origin", r.RemoteAddr).Msg("no public snippets found")
                errs.ErrorWithJson(w, http.StatusNotFound, "no snippets found")
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(snippets); err != nil </span><span class="cov0" title="0">{
                s.Logger.Error().Str("function", "GetPublicSnippets").Str("origin", r.RemoteAddr).Msg("failed to encode snippets")
                errs.ErrorWithJson(w, http.StatusInternalServerError, "failed to encode snippets as JSON")
                return
        }</span>
}

func (s *SnippetService) DeleteSnippet(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        defer r.Body.Close()
        path := r.URL.Path
        idString := strings.TrimPrefix(path, "/api/v1/user/snippets/")
        id, err := strconv.Atoi(idString)
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "DeleteSnippet").Str("origin", r.RemoteAddr).Msg("failed to parse snippet id in uri")
                errs.ErrorWithJson(w, http.StatusBadRequest, "failed to parse snippet id in uri")
                return
        }</span>

        <span class="cov8" title="1">if id &lt;= 0 </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "DeleteSnippet").Str("origin", r.RemoteAddr).Msg("Snippet id must be a positive integer")
                errs.ErrorWithJson(w, http.StatusBadRequest, "Snippet id must be a positive integer")
                return
        }</span>

        <span class="cov8" title="1">if err := dba.DeleteSnippet(s.Db, id); err != nil </span><span class="cov0" title="0">{
                s.Logger.Error().Int("snippetID", id).Str("function", "DeleteSnippet").Str("origin", r.RemoteAddr).Msg("failed to delete snippet")
                errs.ErrorWithJson(w, http.StatusBadRequest, "failed to delete snippet")
                return
        }</span>

        <span class="cov8" title="1">s.Logger.Info().Int("snippetID", id).Str("function", "DeleteSnippet").Str("origin", r.RemoteAddr).Msg("Successfully deleted snippet")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package users

import (
        "regexp"
)

func VerifyEmail(email string) bool <span class="cov8" title="1">{
        if email == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">regex := `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`
        re := regexp.MustCompile(regex)

        return re.MatchString(email)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package users

import (
        "fmt"
        "net/http"
        "strconv"
        "sync"
        "time"

        jsoniter "github.com/json-iterator/go"
        dba "github.com/scott-mescudi/codelet/service/data_access"
        auth "github.com/scott-mescudi/codelet/shared/auth"
        errs "github.com/scott-mescudi/codelet/shared/errors"
        "golang.org/x/crypto/bcrypt"
)

var json = jsoniter.ConfigCompatibleWithStandardLibrary

const ACCESS = 0
const REFRESH = 1

var SignupPool = &amp;sync.Pool{
        New: func() any <span class="cov8" title="1">{
                return &amp;UserSignup{}
        }</span>,
}

var LoginPool = &amp;sync.Pool{
        New: func() any <span class="cov8" title="1">{
                return &amp;UserLogin{}
        }</span>,
}

var UpdatePasswordPool = &amp;sync.Pool{
        New: func() any <span class="cov8" title="1">{
                return &amp;ChangePassword{}
        }</span>,
}

func (s *UserService) Signup(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        defer r.Body.Close()
        if r.Header.Get("Content-Type") != "application/json" </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "Signup").Str("origin", r.RemoteAddr).Msg("Invalid Content-Type, expected application/json")
                errs.ErrorWithJson(w, http.StatusUnprocessableEntity, "Content-Type header must be application/json")
                return
        }</span>

        <span class="cov8" title="1">var info = SignupPool.Get().(*UserSignup)
        defer SignupPool.Put(info)
        if err := json.NewDecoder(r.Body).Decode(&amp;info); err != nil </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "Signup").Str("origin", r.RemoteAddr).Msg("Failed to decode body into json")
                errs.ErrorWithJson(w, http.StatusUnprocessableEntity, "Invalid JSON payload: "+err.Error())
                return
        }</span>

        <span class="cov8" title="1">if !VerifyEmail(info.Email) </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "Signup").Str("origin", r.RemoteAddr).Msg("Invalid email")
                errs.ErrorWithJson(w, http.StatusBadRequest, "Email field is invalid")
                return
        }</span>

        <span class="cov8" title="1">if info.Password == "" </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "Signup").Str("origin", r.RemoteAddr).Msg("Invalid password")
                errs.ErrorWithJson(w, http.StatusBadRequest, "Password field is required")
                return
        }</span>

        <span class="cov8" title="1">if info.Username == "" </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "Signup").Str("origin", r.RemoteAddr).Msg("Invalid Username")
                errs.ErrorWithJson(w, http.StatusBadRequest, "Username field is required")
                return
        }</span>

        <span class="cov8" title="1">if info.Role == "" </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "Signup").Str("origin", r.RemoteAddr).Msg("Invalid Role")
                errs.ErrorWithJson(w, http.StatusBadRequest, "Role field is required")
                return
        }</span>

        <span class="cov8" title="1">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(info.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Warn().Str("function", "Signup").Str("origin", r.RemoteAddr).Msg("Failed to hash password")
                errs.ErrorWithJson(w, http.StatusInternalServerError, "Internal server error while processing password")
                return
        }</span>

        <span class="cov8" title="1">err = dba.AddUser(s.Db, info.Username, info.Email, info.Role, string(hashedPassword))
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error().Str("function", "Signup").Str("origin", r.RemoteAddr).Err(err)
                errs.ErrorWithJson(w, http.StatusBadRequest, fmt.Sprintf("Failed to create user: %v", err))
                return
        }</span>

        <span class="cov8" title="1">s.Logger.Info().Str("function", "Signup").Str("origin", r.RemoteAddr).Str("user", info.Username).Msg("Created new user")
        w.WriteHeader(http.StatusCreated)</span>
}

func (s *UserService) Login(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        defer r.Body.Close()
        if r.Header.Get("Content-Type") != "application/json" </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "Login").Str("origin", r.RemoteAddr).Msg("Invalid Content-Type, expected application/json")
                errs.ErrorWithJson(w, http.StatusUnprocessableEntity, "Content-Type header must be application/json")
                return
        }</span>

        <span class="cov8" title="1">var info = LoginPool.Get().(*UserLogin)
        defer LoginPool.Put(info)
        if err := json.NewDecoder(r.Body).Decode(&amp;info); err != nil </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "Login").Str("origin", r.RemoteAddr).Msg("Failed to decode body into json")
                errs.ErrorWithJson(w, http.StatusUnprocessableEntity, "Invalid JSON payload: "+err.Error())
                return
        }</span>

        <span class="cov8" title="1">if info.Email == "" </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "Login").Str("origin", r.RemoteAddr).Msg("Invalid email")
                errs.ErrorWithJson(w, http.StatusBadRequest, "Email field is invalid")
                return
        }</span>

        <span class="cov8" title="1">if info.Password == "" </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "Login").Str("origin", r.RemoteAddr).Msg("Invalid password")
                errs.ErrorWithJson(w, http.StatusBadRequest, "Password field is required")
                return
        }</span>

        <span class="cov8" title="1">userID, passwordHash, err := dba.GetUserPasswordHash(s.Db, info.Email)
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "Login").Str("origin", r.RemoteAddr).Err(err).Msg("Failed to retrieve user password hash")
                errs.ErrorWithJson(w, http.StatusUnauthorized, "Invalid email or password")
                return
        }</span>

        <span class="cov8" title="1">if err := bcrypt.CompareHashAndPassword([]byte(passwordHash), []byte(info.Password)); err != nil </span><span class="cov0" title="0">{
                s.Logger.Warn().Str("function", "Login").Str("origin", r.RemoteAddr).Msg("Invalid password comparison")
                errs.ErrorWithJson(w, http.StatusUnauthorized, "Invalid email or password")
                return
        }</span>

        <span class="cov8" title="1">accessToken := auth.GenerateHMac(userID, ACCESS, time.Now().Add(15*time.Minute))
        refreshToken := auth.GenerateHMac(userID, REFRESH, time.Now().Add(48*time.Hour))

        if err := dba.AddRefreshToken(s.Db, refreshToken, userID); err != nil </span><span class="cov0" title="0">{
                s.Logger.Error().Str("function", "Login").Str("origin", r.RemoteAddr).Err(err).Msg("Failed to add refresh token")
                errs.ErrorWithJson(w, http.StatusInternalServerError, "Failed to complete login process")
                return
        }</span>

        <span class="cov8" title="1">http.SetCookie(w, &amp;http.Cookie{
                Name:     "CODELET-JWT-REFRESH-TOKEN",
                Value:    refreshToken,
                Expires:  time.Now().Add(48 * time.Hour),
                HttpOnly: true,
                SameSite: http.SameSiteNoneMode,
                Secure:   true,
        })

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(map[string]string{"access_token": accessToken}); err != nil </span><span class="cov0" title="0">{
                s.Logger.Error().Str("function", "Login").Err(err).Msg("Failed to encode response")
                errs.ErrorWithJson(w, http.StatusInternalServerError, "Failed to generate response")
                return
        }</span>

        <span class="cov8" title="1">s.Logger.Info().Str("function", "Login").Str("origin", r.RemoteAddr).Msg("User logged in successfully")</span>
}

func (s *UserService) Refresh(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        defer r.Body.Close()
        cookie, err := r.Cookie("CODELET-JWT-REFRESH-TOKEN")
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "Refresh").Str("origin", r.RemoteAddr).Err(err).Msg("No refresh token provided")
                errs.ErrorWithJson(w, http.StatusUnauthorized, "No refresh token provided")
                return
        }</span>

        <span class="cov8" title="1">if cookie.Value == "" </span><span class="cov0" title="0">{
                s.Logger.Warn().Str("function", "Refresh").Str("origin", r.RemoteAddr).Msg("Invalid refresh token")
                errs.ErrorWithJson(w, http.StatusUnauthorized, "Invalid refresh token")
                return
        }</span>

        <span class="cov8" title="1">userID, tokenType, err := auth.ValidateHmac(cookie.Value)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Warn().Str("function", "Refresh").Str("origin", r.RemoteAddr).Err(err).Msg("Invalid or expired refresh token")
                errs.ErrorWithJson(w, http.StatusUnauthorized, "Invalid or expired refresh token")
                return
        }</span>

        <span class="cov8" title="1">if tokenType != REFRESH </span><span class="cov0" title="0">{
                s.Logger.Warn().Str("function", "Refresh").Str("origin", r.RemoteAddr).Msg("Invalid token type")
                errs.ErrorWithJson(w, http.StatusUnauthorized, "Invalid token type")
                return
        }</span>

        <span class="cov8" title="1">if userID == -1 </span><span class="cov0" title="0">{
                s.Logger.Warn().Str("function", "Refresh").Str("origin", r.RemoteAddr).Msg("Invalid user token")
                errs.ErrorWithJson(w, http.StatusUnauthorized, "Invalid user token")
                return
        }</span>

        <span class="cov8" title="1">dbToken, err := dba.GetRefreshToken(s.Db, userID)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error().Str("function", "Refresh").Str("origin", r.RemoteAddr).Err(err).Msg("Failed to retrieve refresh token from database")
                errs.ErrorWithJson(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">if cookie.Value != dbToken </span><span class="cov0" title="0">{
                s.Logger.Warn().Str("function", "Refresh").Str("origin", r.RemoteAddr).Msg("Refresh token mismatch")
                w.WriteHeader(http.StatusForbidden)
                return
        }</span>

        <span class="cov8" title="1">accessToken := auth.GenerateHMac(userID, ACCESS, time.Now().Add(15*time.Minute))
        refreshToken := auth.GenerateHMac(userID, REFRESH, time.Now().Add(48*time.Hour))

        if err := dba.AddRefreshToken(s.Db, refreshToken, userID); err != nil </span><span class="cov0" title="0">{
                s.Logger.Error().Str("function", "Refresh").Str("origin", r.RemoteAddr).Err(err).Msg("Failed to add new refresh token")
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">http.SetCookie(w, &amp;http.Cookie{
                Name:     "CODELET-JWT-REFRESH-TOKEN",
                Value:    refreshToken,
                Expires:  time.Now().Add(48 * time.Hour),
                HttpOnly: true,
                SameSite: http.SameSiteNoneMode,
                Secure:   true,
        })

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(map[string]string{"acess_token": accessToken}); err != nil </span><span class="cov0" title="0">{
                s.Logger.Error().Str("function", "Refresh").Err(err).Msg("Failed to encode response")
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">s.Logger.Info().Str("function", "Refresh").Str("origin", r.RemoteAddr).Msg("Refresh token successfully renewed")
        w.WriteHeader(http.StatusOK)</span>
}

func (s *UserService) Logout(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()
        useridStr := r.Header.Get("X-USERID")
        if useridStr == "" </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">userID, err := strconv.Atoi(useridStr)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">http.SetCookie(w, &amp;http.Cookie{
                Name:     "CODELET-JWT-REFRESH-TOKEN",
                Value:    "",
                Expires:  time.Now(),
                HttpOnly: true,
                SameSite: http.SameSiteNoneMode,
                Secure:   true,
        })

        if err := dba.AddRefreshToken(s.Db, "", userID); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)</span>
}

func (s *UserService) ChangePassword(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Header.Get("Content-Type") != "application/json" </span><span class="cov0" title="0">{
                s.Logger.Warn().Str("function", "ChangePassword").Str("origin", r.RemoteAddr).Msg("Invalid Content-Type, expected application/json")
                errs.ErrorWithJson(w, http.StatusUnprocessableEntity, "Content-Type header must be application/json")
                return
        }</span>

        <span class="cov8" title="1">defer r.Body.Close()

        var info = UpdatePasswordPool.Get().(*ChangePassword)
        defer UpdatePasswordPool.Put(info)
        if err := json.NewDecoder(r.Body).Decode(&amp;info); err != nil </span><span class="cov0" title="0">{
                s.Logger.Warn().Str("function", "ChangePassword").Str("origin", r.RemoteAddr).Err(err).Msg("Failed to decode body into json")
                errs.ErrorWithJson(w, http.StatusUnprocessableEntity, "Invalid JSON payload: "+err.Error())
                return
        }</span>

        <span class="cov8" title="1">if info.OldPassword == "" || info.NewPassword == "" </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "ChangePassword").Str("origin", r.RemoteAddr).Msg("Both old and new passwords are required")
                errs.ErrorWithJson(w, http.StatusBadRequest, "Both old and new passwords are required")
                return
        }</span>

        <span class="cov8" title="1">useridStr := r.Header.Get("X-USERID")
        if useridStr == "" </span><span class="cov0" title="0">{
                s.Logger.Warn().Str("function", "ChangePassword").Str("origin", r.RemoteAddr).Msg("User ID not found in request")
                errs.ErrorWithJson(w, http.StatusUnauthorized, "User ID not found in request")
                return
        }</span>

        <span class="cov8" title="1">userID, err := strconv.Atoi(useridStr)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error().Str("function", "ChangePassword").Err(err).Msg("Failed to parse user ID")
                errs.ErrorWithJson(w, http.StatusInternalServerError, "Invalid user ID format")
                return
        }</span>

        <span class="cov8" title="1">passwordHash, err := dba.GetUserPasswordHashViaID(s.Db, userID)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Warn().Str("function", "ChangePassword").Str("origin", r.RemoteAddr).Msg("User not found")
                errs.ErrorWithJson(w, http.StatusUnauthorized, "User not found")
                return
        }</span>

        <span class="cov8" title="1">if err := bcrypt.CompareHashAndPassword([]byte(passwordHash), []byte(info.OldPassword)); err != nil </span><span class="cov8" title="1">{
                s.Logger.Warn().Str("function", "ChangePassword").Str("origin", r.RemoteAddr).Msg("Old password does not match")
                w.WriteHeader(http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">hashedNewPassword, err := bcrypt.GenerateFromPassword([]byte(info.NewPassword), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error().Str("function", "ChangePassword").Err(err).Msg("Failed to hash new password")
                errs.ErrorWithJson(w, http.StatusInternalServerError, "Failed to process new password")
                return
        }</span>

        <span class="cov8" title="1">err = dba.UpdatePassword(s.Db, string(hashedNewPassword), userID)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error().Str("function", "ChangePassword").Err(err).Msg("Failed to update password in database")
                errs.ErrorWithJson(w, http.StatusInternalServerError, "Failed to update password in database")
                return
        }</span>

        <span class="cov8" title="1">s.Logger.Info().Str("function", "ChangePassword").Str("origin", r.RemoteAddr).Msg("Password changed successfully")
        w.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package dataaccess

import (
        "context"
        "time"

        "github.com/jackc/pgx/v5/pgxpool"
        cmp "github.com/scott-mescudi/codelet/shared/compression"
)

func AddSnippet(dbConn *pgxpool.Pool, userID int, language, description, title string, code string, private, favorite bool, tags []string, created time.Time, updated time.Time) error <span class="cov8" title="1">{
        compressed, err := cmp.CompressZSTD([]byte(code))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">_, err = dbConn.Exec(context.Background(), "INSERT INTO snippets(userid, language, title, code, description, private, tags, created, updated, favorite) VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)", userID, language, title, compressed, description, private, tags, created, updated, favorite)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func GetSnippetsByUserID(dbConn *pgxpool.Pool, userID, limit, offset int) ([]DBsnippet, error) <span class="cov8" title="1">{
        var data []DBsnippet
        rows, err := dbConn.Query(context.Background(), "SELECT id, language, title, code, description, private, tags, created, updated, favorite FROM snippets WHERE userid=$1 LIMIT $2 OFFSET $3", userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                var snippet DBsnippet
                var code []byte
                err := rows.Scan(&amp;snippet.ID, &amp;snippet.Language, &amp;snippet.Title, &amp;code, &amp;snippet.Description, &amp;snippet.Private, &amp;snippet.Tags, &amp;snippet.Created, &amp;snippet.Updated, &amp;snippet.Favorite)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">decompressedData, err := cmp.DecompressZSTD(code)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">snippet.Code = string(decompressedData)
                data = append(data, snippet)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return data, nil</span>

}

func GetAllSnippetsByUserID(dbConn *pgxpool.Pool, userID int) ([]DBsnippet, error) <span class="cov0" title="0">{
        var data []DBsnippet
        rows, err := dbConn.Query(context.Background(), "SELECT id, language, title, code, description, private, tags, created, updated, favorite FROM snippets WHERE userid=$1", userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var snippet DBsnippet
                var code []byte
                err := rows.Scan(&amp;snippet.ID, &amp;snippet.Language, &amp;snippet.Title, &amp;code, &amp;snippet.Description, &amp;snippet.Private, &amp;snippet.Tags, &amp;snippet.Created, &amp;snippet.Updated, &amp;snippet.Favorite)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">decompressedData, err := cmp.DecompressZSTD(code)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">snippet.Code = string(decompressedData)
                data = append(data, snippet)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return data, nil</span>

}

func GetPublicSnippets(dbConn *pgxpool.Pool, limit, offset int) ([]DBsnippet, error) <span class="cov8" title="1">{
        var data []DBsnippet
        rows, err := dbConn.Query(context.Background(), "SELECT id, language, title, code, description, private, tags, created, updated, favorite FROM snippets WHERE private=false LIMIT $1 OFFSET $2", limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                var snippet DBsnippet
                var code []byte
                err := rows.Scan(&amp;snippet.ID, &amp;snippet.Language, &amp;snippet.Title, &amp;code, &amp;snippet.Description, &amp;snippet.Private, &amp;snippet.Tags, &amp;snippet.Created, &amp;snippet.Updated, &amp;snippet.Favorite)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">decompressedData, err := cmp.DecompressZSTD(code)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">snippet.Code = string(decompressedData)
                data = append(data, snippet)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return data, nil</span>

}

func DeleteSnippet(dbConn *pgxpool.Pool, snippetID int) error <span class="cov8" title="1">{
        tx, err := dbConn.Begin(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback(context.Background())

        _, err = dbConn.Exec(context.Background(), "DELETE FROM snippets WHERE id=$1", snippetID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return tx.Commit(context.Background())</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package dataaccess

import (
        "context"
        "fmt"

        "github.com/jackc/pgx/v5/pgxpool"
)

func ConnectToDatabase(postgresURI string) (*pgxpool.Pool, error) <span class="cov8" title="1">{
        config, err := pgxpool.ParseConfig(postgresURI)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to parse database URL: %w", err)
        }</span>

        <span class="cov8" title="1">dbPool, err := pgxpool.NewWithConfig(context.Background(), config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to create connection pool: %w", err)
        }</span>

        // Ensure the database is reachable
        <span class="cov8" title="1">if err := dbPool.Ping(context.Background()); err != nil </span><span class="cov0" title="0">{
                dbPool.Close()
                return nil, fmt.Errorf("unable to ping database: %w", err)
        }</span>

        <span class="cov8" title="1">return dbPool, nil</span>
}

func AddUser(dbConn *pgxpool.Pool, username, email, role, password string) error <span class="cov8" title="1">{
        _, err := dbConn.Exec(context.Background(), "INSERT INTO users(username, email, role, password_hash) VALUES($1, $2, $3, $4)", username, email, role, password)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func GetUserPasswordHash(dbConn *pgxpool.Pool, email string) (int, string, error) <span class="cov8" title="1">{
        var id int
        var hash string
        row := dbConn.QueryRow(context.Background(), "SELECT password_hash, id FROM users WHERE email=$1", email)
        if err := row.Scan(&amp;hash, &amp;id); err != nil </span><span class="cov8" title="1">{
                return -1, "", err
        }</span>

        <span class="cov8" title="1">return id, hash, nil</span>
}

func GetUserPasswordHashViaID(dbConn *pgxpool.Pool, id int) (string, error) <span class="cov8" title="1">{
        var hash string
        row := dbConn.QueryRow(context.Background(), "SELECT password_hash FROM users WHERE id=$1", id)
        if err := row.Scan(&amp;hash); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return hash, nil</span>
}

func UpdatePassword(dbConn *pgxpool.Pool, passwordHash string, userID int) error <span class="cov8" title="1">{
        _, err := dbConn.Exec(context.Background(), "UPDATE users SET password_hash=$1 WHERE id=$2", passwordHash, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func AddRefreshToken(dbConn *pgxpool.Pool, acessToken string, userID int) error <span class="cov8" title="1">{
        _, err := dbConn.Exec(context.Background(), "UPDATE users SET refresh_token=$1 WHERE id=$2", acessToken, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func GetRefreshToken(dbConn *pgxpool.Pool, userID int) (string, error) <span class="cov8" title="1">{
        var refreshToken string
        row := dbConn.QueryRow(context.Background(), "SELECT refresh_token FROM users WHERE id=$1", userID)
        if err := row.Scan(&amp;refreshToken); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return refreshToken, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package middleware

import (
        "net/http"
        "strconv"

        auth "github.com/scott-mescudi/codelet/shared/auth"
)

const ACCESS = 0
const REFRESH = 1

func AuthMiddleware(next http.HandlerFunc) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                token := r.Header.Get("Authorization")
                if token == "" </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusForbidden)
                        return
                }</span>

                <span class="cov8" title="1">userID, tokenType, err := auth.ValidateHmac(token)
                if err != nil </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusForbidden)
                        return
                }</span>

                <span class="cov8" title="1">if tokenType != ACCESS </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusForbidden)
                        return
                }</span>

                <span class="cov8" title="1">r.Header.Add("X-USERID", strconv.Itoa(userID))
                next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import (
        "net/http"
        "os"
)

var CORS_ORIGIN = os.Getenv("CORS_ORIGIN")

func CorsMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Access-Control-Allow-Origin", CORS_ORIGIN) // Replace with your frontend URL, in testing with postman set to *
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
                w.Header().Set("Access-Control-Allow-Credentials", "true") // Allow credentials (cookies, etc.)

                // If the request method is OPTIONS (preflight), just return No Content
                if r.Method == http.MethodOptions </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusNoContent)
                        return
                }</span>

                // Proceed with the actual request
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package server

import (
        "fmt"

        "net/http"
        "os"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        snippetMethods "github.com/scott-mescudi/codelet/service/api/snippets"
        userMethods "github.com/scott-mescudi/codelet/service/api/users"
        dataAccess "github.com/scott-mescudi/codelet/service/data_access"
        middleware "github.com/scott-mescudi/codelet/service/middleware"
)

func NewCodeletServer() <span class="cov0" title="0">{
        if err := os.MkdirAll("/src/logs", 0755); err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to create logs directory")
        }</span>

        <span class="cov0" title="0">file, err := os.OpenFile("/src/logs/codelet_server_logs.json", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0666)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to open log file")
        }</span>

        <span class="cov0" title="0">log.Logger = zerolog.New(file).With().Timestamp().Logger()

        logger := log.Logger

        app := http.NewServeMux()

        logger.Info().Str("Database uri", os.Getenv("DATABASE_URL")).Msg("Trying to connect to database")
        db, err := dataAccess.ConnectToDatabase(os.Getenv("DATABASE_URL"))
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal().Err(err).Msg("Failed to connect to database")
                return
        }</span>
        <span class="cov0" title="0">defer db.Close()
        logger.Info().Msg("Connected to database")

        srv := userMethods.UserService{Db: db}
        srv2 := snippetMethods.SnippetService{Db: db, Logger: logger}

        app.HandleFunc("/api/v1/ping", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                w.Write([]byte("pong"))
        }</span>)

        <span class="cov0" title="0">app.HandleFunc("POST /api/v1/register", srv.Signup)
        app.HandleFunc("POST /api/v1/login", srv.Login)
        app.HandleFunc("GET /api/v1/refresh", srv.Refresh)

        app.Handle("POST /api/v1/update/password", middleware.AuthMiddleware(srv.ChangePassword))
        app.Handle("POST /api/v1/logout", middleware.AuthMiddleware(srv.Logout))
        app.Handle("POST /api/v1/user/snippets", middleware.AuthMiddleware(srv2.AddSnippet))
        app.Handle("DELETE /api/v1/user/snippets/{id}", middleware.AuthMiddleware(srv2.DeleteSnippet))
        app.Handle("GET /api/v1/user/snippets", middleware.AuthMiddleware(srv2.GetUserSnippets))
        app.HandleFunc("GET /api/v1/public/snippets", srv2.GetPublicSnippets)

        logger.Info().Msg(fmt.Sprintf("Server started on port %v", os.Getenv("APP_PORT")))
        if err := http.ListenAndServe(os.Getenv("APP_PORT"), app); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package auth

import (
        "github.com/golang-jwt/jwt/v5"
        "time"
)

var HMACSecretKey = []byte("apeirbvpijebvejbfpvibfevqepirjvb")
var Issuer = "codelet"

type Claims struct {
        UserID    int
        TokenType int8
        jwt.RegisteredClaims
}

func GenerateHMac(userID int, tokenType int8, timeframe time.Time) string <span class="cov8" title="1">{
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, Claims{
                UserID:    userID,
                TokenType: tokenType,
                RegisteredClaims: jwt.RegisteredClaims{
                        Issuer:    Issuer,
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        ExpiresAt: jwt.NewNumericDate(timeframe),
                },
        })

        tkstring, err := token.SignedString(HMACSecretKey)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return tkstring</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package auth

import (
        "fmt"

        "github.com/golang-jwt/jwt/v5"
)

func ValidateHmac(tokenString string) (int, int8, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov8" title="1">return HMACSecretKey, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return -1, -1, err
        }</span>

        <span class="cov8" title="1">claims, ok := token.Claims.(*Claims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return -1, -1, fmt.Errorf("invalid token")
        }</span>

        <span class="cov8" title="1">if claims.Issuer != Issuer </span><span class="cov0" title="0">{
                return -1, -1, fmt.Errorf("invalid issuer")
        }</span>

        <span class="cov8" title="1">return claims.UserID, claims.TokenType, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package compression

import (
        "bytes"
        "io"

        "github.com/klauspost/compress/zstd"
)

func CompressZSTD(data []byte) ([]byte, error) <span class="cov8" title="1">{
        var buf bytes.Buffer
        encoder, err := zstd.NewWriter(&amp;buf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">_, err = encoder.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">encoder.Close()
        return buf.Bytes(), err</span>
}

func DecompressZSTD(data []byte) ([]byte, error) <span class="cov8" title="1">{
        b := bytes.NewBuffer(data)
        decoder, err := zstd.NewReader(b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer decoder.Close()

        var out bytes.Buffer
        if _, err = io.Copy(&amp;out, decoder); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package errors

import (
        "log"
        "net/http"

        jsoniter "github.com/json-iterator/go"
)

var json = jsoniter.ConfigCompatibleWithStandardLibrary

func ErrorWithJson(w http.ResponseWriter, code int, message string) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(code)

        response := map[string]interface{}{
                "error": message,
                "code":  code,
        }

        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to encode JSON response: %v\n", err)
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
